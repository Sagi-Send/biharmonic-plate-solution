classdef Plate
    properties (Constant)
        h  = 0.5;   % half-thickness (total thickness = 2h = 1)
        E  = 1.0;   % Young's modulus
        nu = 0.20;  % Poisson's ratio
        w0 = 1.0;   % load amplitude
    end
    properties (Dependent)
        l           % span, computed from h and S
    end
    properties
        k           % exponential load exponent
        S           % slenderness S = l/(2h)
        Nx; Ny      % grid
    end
    
    methods
        % Constructor
        function obj = Plate(k, slenderness)
            obj.k = k;  obj.S = slenderness;
            obj.Nx = Nx;    obj.Ny = Ny;
        end

        function l = get.l(obj)
            l = 2*obj.h * obj.S;      % if S = l/(2h)
        end

        %% ===== solver: returns u(x,y), v(x,y), grids, and stresses =====
        function [u,v,xv,yv,sigx,sigy,tauxy] = solve_plate(obj)

            Nmode = obj.Nmode;  k = obj.k; l = obj.l;   h = obj.h;
            E = obj.E;          nu = ojb.nu;    w0 = obj.w0;
            Nx = obj.Nx;    Ny = obj.Ny;
        
            % constants and grids
            G = E/(2*(1+nu));
            I = (2/3)*h^3;             % second moment per unit width for thickness 2h        
            xv = linspace(0,l,Nx);
            yv = linspace(-h,h,Ny);
            [X,Y] = meshgrid(xv,yv);
        
            dx = xv(2)-xv(1);
            dy = yv(2)-yv(1);
        
            [~,iy0] = min(abs(yv-0));   % y=0 index
            ixL = Nx;                   % x=l index
        
            % Fourier coefficients for w(x) = w0*exp(k*x/l)
            a0 = w0*(exp(k)-1)/k;
            n  = 1:Nmode;
            an = 2*w0*k*(exp(k)-1) ./ (k^2 + (2*pi*n).^2);
            bn = -(exp(k)-1)*w0*(4*pi*n) ./ (k^2 + (2*pi*n).^2);
        
            % n=0 stresses (polynomial particular)
            sigx  = (a0/(2*I))*( (l - X).*X.*Y ) + (a0/(2*I))*((2/3)*Y.^3 - (2/5)*h^2.*Y);
            sigy  = -(a0/(2*I))*((1/3)*Y.^3 - h^2.*Y + (2/3)*h^3);
            tauxy = -(a0/(2*I))*((h^2 - Y.^2).*(X - l/2));
        
            % add modal stresses from closed forms
            for m = 1:Nmode
                alpha = 2*pi*m/l;
                ah = alpha*h; ch = cosh(ah); sh = sinh(ah);
                S2 = sinh(2*ah);
                Dp = S2 + 2*alpha*h;          % D_+
                Dm = S2 - 2*alpha*h;          % D_-
        
                cy = cosh(alpha*Y);
                sy = sinh(alpha*Y);
                cX = cos(alpha*X);
                sX = sin(alpha*X);
        
                A11 = ( (ah*ch - sh).*cy - alpha*Y.*sy.*sh )/Dp ...
                    - ( (ah*sh - ch).*sy - alpha*Y.*cy.*ch )/Dm;
        
                A12 = ( (ah*sh + ch).*sy - alpha*Y.*cy.*ch )/Dm ...
                    - ( (ah*ch + sh).*cy - alpha*Y.*sy.*sh )/Dp;
        
                % a_n (cos family)
                sigx  = sigx  + an(m).*cX .* A11;
                sigy  = sigy  + an(m).*cX .* A12;
                tauxy = tauxy + an(m).*sX .* ( (ah*ch).*sy - alpha*Y.*cy.*sh )/Dp ...
                              - an(m).*sX .* ( (ah*sh).*cy - alpha*Y.*sy.*ch )/Dm;
        
                % b_n (sin family)
                sigx  = sigx  + bn(m).*sX .* A11;
                sigy  = sigy  + bn(m).*sX .* A12;
                tauxy = tauxy + bn(m).*cX .* ( (ah*sh).*cy - alpha*Y.*sy.*ch )/Dm ...
                              - bn(m).*cX .* ( (ah*ch).*sy - alpha*Y.*cy.*sh )/Dp;
            end
        
            % particular displacements by line integration (plane stress strains)
            epsx = (sigx - nu*sigy)/E;
            epsy = (sigy - nu*sigx)/E;
        
            u0 = zeros(Ny,Nx);
            for j = 1:Ny
                u0(j,:) = cumtrapz(xv, epsx(j,:));
            end
        
            v0 = zeros(Ny,Nx);
            for i = 1:Nx
                col  = epsy(:,i);                    % keep as column
                vtmp = cumtrapz(yv, col);            % integrate along y
                v0(:,i) = vtmp - vtmp(iy0);          % set v0(x,0)=0
            end
        
            % Section-averaged split: fit R ≈ F(x) + G(y) - K in LS sense
            [~,Uy] = gradient(u0, dx, dy);           % Uy = ∂u/∂y  (correct outputs)
            [Vx,~] = gradient(v0, dx, dy);           % Vx = ∂v/∂x
            R = Uy + Vx - tauxy./G;
        
            K     = mean(R(:));
            Fbase = mean(R,1) - K;                   % function of x
            Gbase = mean(R,2).' - K;                 % function of y
        
            % f2'(x) = -F(x), f1'(y) = -G(y)
            f2 = -cumtrapz(xv, Fbase);      f2 = f2(:).';     % 1xNx
            f1 = -cumtrapz(yv, Gbase.');    f1 = f1(:);       % Nyx1
            f1 = f1 - f1(iy0);                                   % set f1(0)=0
        
            % add integration functions
            u = u0 + repmat(f1, 1, Nx);
            v = v0 + repmat(f2, Ny, 1);
        
            % clamp at (x=l,y=0): zero translations
            u = u - u(iy0,ixL);
            v = v - v(iy0,ixL);
        
            % enforce zero rotation at clamp with backward difference (rigid-body)
            S = (v(iy0,ixL) - v(iy0,ixL-1))/dx;      % slope at x=l
            u = u + S * (yv.' * ones(1,Nx));         % add S*y
            v = v - S * (ones(Ny,1) * (xv - l));     % subtract S*(x-l)
        end

    end
end

